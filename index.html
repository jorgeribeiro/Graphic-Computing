<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1" charset="utf-8"/>
<style>
body {
    font-family: Verdana,sans-serif;
    font-size: 13px;
}
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="init()">
<p id="currMousePos">Mouse position on canvas: </p>
<p id="status">Movable: </p> <!-- Para testes necessários -->
<canvas id="myCanvas" width="1280" height="550">
</body>

<script>

// Uma linha contém uma coordenada inicial (start) e uma coordenada final (end)
function Line(start, end) {
    this.start = start || 0;
    this.end = end || 0;
}

// Um objeto é um vetor com n linhas
function Object() {
    this.lines = [];
}

// Determina se a posição do mouse é válida sobre as linhas
Object.prototype.contains = function(currMousePos) {
    var l = this.lines.length;
    for (var i = 0; i < l; i++) {
        var line = this.lines[i];
        var a = line.start.y - line.end.y;
        var b = line.end.x - line.start.x;
        var c = (line.start.x * line.end.y) - (line.end.x * line.start.y);
        // Equação da reta: ax + by + c
        var cross = (a * currMousePos.x) + (b * currMousePos.y) + c;
        console.log("a = " + a + ", b = " + b + ", c = "+ c);
        console.log("cross = " + cross + ", cross / c = " + Math.abs(cross / c));
        // Tolerância para o mouse estar em posição válida
        var tol = 0.1; 
        if(cross == 0 || Math.abs(cross / c) < tol) {
            if(Math.abs(line.end.x - line.start.x) >= Math.abs(line.end.y - line.start.y)) {
                return (((line.end.x - line.start.x) > 0) ? (line.start.x <= currMousePos.x && currMousePos.x <= line.end.x) : (line.end.x <= currMousePos.x && currMousePos.x <= line.start.x));
            } else {
                return (((line.end.y - line.start.y) > 0) ? (line.start.y <= currMousePos.y && currMousePos.y <= line.end.y) : (line.end.y <= currMousePos.y && currMousePos.y <= line.start.y));
            }
        }
        return false;
    }
}

// Desenha o objeto em um context
Object.prototype.draw = function(ctx) {
    // Desenha cada linha de um objeto
    var l = this.lines.length;
    for (var i = 0; i < l; i++) {
        var line = this.lines[i];
        ctx.beginPath();
        ctx.moveTo(line.start.x, line.start.y);
        ctx.lineTo(line.end.x, line.end.y);
        ctx.stroke();
    } 
}

// CanvasState toma conta do estado do canvas
// Nele encontram-se os métodos para eventos do mouse, e também métodos de update no canvas, no caso de alguma movimentação ou transformação em algum objeto presente nele
// Os objetos (linhas, polígonos e poligonais) são salvos na lista shapes[]
function CanvasState(canvas) {
    // Atributos
    this.canvas = canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.ctx = canvas.getContext('2d');

    this.valid = false;
    this.objects = [];  // Objetos criados na tela
    this.dragging = false; // Flag para quando se está arrastando um objeto
    this.drawing = false; // Flag para quando se está desenhando um objeto
    this.selection = null; // Objeto selecionado
    this.dragoffx = 0;
    this.dragoffy = 0;
    this.startline = true; // Usado para desenhar linhas
    this.startMousePos = 0, 0; // Salva o primeiro click do mouse ao desenhar. Não se usa 'this' para referenciar a esse atributo. Porque?

    // Dentro dos eventos do mouse, o "this" corresponde ao canvas, por isso precisa-se guardar o CanvasState em uma variável
    var myState = this;

    canvas.addEventListener('mousemove', function(e) {
        var currMousePos = myState.getMousePos(e);
        if(myState.drawing) {
            myState.drawLine(currMousePos);
            myState.valid = false;
        }
        myState.writeMousePos("Mouse position on canvas: " + currMousePos.x + ',' + currMousePos.y);
        myState.isMovable(currMousePos);
    });

    canvas.addEventListener('click', function(e) {
        var currMousePos = myState.getMousePos(e);
        if(myState.startline) { // Primeiro click
            myState.startline = false; 
            myState.drawing = true;
            startMousePos = currMousePos;
        } else {                // Segundo click
            myState.startline = true; 
            myState.drawing = false;
            myState.addObject(new Line(startMousePos, currMousePos));
        }
    });

    this.interval = 10;
    setInterval(function() { myState.draw(); }, myState.interval);
}

// Prototype corresponde a adicionar um novo atributo ao "objeto" existente
CanvasState.prototype.addObject = function(line) {
    var o = new Object();
    o.lines.push(line);
    this.objects.push(o);
    this.valid = false;
}

// Limpa a tela para redesenhar o canvas em cada interval
CanvasState.prototype.clear = function() {
    this.ctx.clearRect(0, 0, this.width, this.height);
}

// Método chamado pelo INTERVAL
// Limpa o canvas e redesenha todos os objetos presentes em objects[]
CanvasState.prototype.draw = function() {
    if (!this.valid) {
        var ctx = this.ctx;
        var objects = this.objects;
        this.clear();
        if(this.drawing) { this.ctx.stroke(); } // Evita que desenhe a mesma linha duas vezes

        // Desenha todos os objetos
        var l = objects.length;
        for (var i = 0; i < l; i++) {
            var object = objects[i];
            objects[i].draw(ctx);
        }
        this.valid = true;
    }
}

CanvasState.prototype.getMousePos = function(e) {
    var rect = this.canvas.getBoundingClientRect();
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

CanvasState.prototype.writeMousePos = function(message) {
    document.getElementById("currMousePos").innerHTML = message;
}

CanvasState.prototype.drawLine = function(currMousePos) {
    this.drawing = true;
    this.ctx.beginPath();
    this.ctx.moveTo(startMousePos.x, startMousePos.y);
    this.ctx.lineTo(currMousePos.x, currMousePos.y);
}

CanvasState.prototype.isMovable = function(currMousePos) {
    var l = this.objects.length;
    for (var i = 0; i < l; i++) {
        var object = this.objects[i];
        document.getElementById("status").innerHTML = "Movable: " + object.contains(currMousePos);
    }
}

function init() {
    var s = new CanvasState(document.getElementById("myCanvas"));
}

</script>

</html>