<!DOCTYPE html>
<html>
<head>
<title>HTML5 Canvas Paint</title>
<meta name="viewport" content="width=device-width, initial-scale=1" charset="utf-8"/>
<style>
body {
    font-family: Verdana,sans-serif;
    font-size: 13px;
}
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
.btn-group .button {
    background-color: #4CAF50;
    border: 1px solid green;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    cursor: pointer;
    float: left;
}
.btn-group .button:not(:last-child) {
    border-right: none;
}
.btn-group .button:hover {
    background-color: #3e8e41;
}
</style>
</head>
<body>
<p id="currMousePos">Mouse position on canvas: </p>
<p id="status" hidden="true">Status: </p> <!-- Para testes necessários -->
<div class="btn-group">
  <button id="pointbt" class="button" onclick="s.setButton(this.id)">Point</button>
  <button id="linebt" class="button" onclick="s.setButton(this.id)">Line</button>
  <button id="polygonbt" class="button" onclick="s.setButton(this.id)">Polygon</button>
  <button id="bezierbt" class="button" onclick="s.setButton(this.id)">Bezier</button>
  <button id="movebt" class="button" onclick="s.setButton(this.id)">Move</button>
  <button id="rotatebt" class="button" onclick="s.setButton(this.id)">Rotate</button>
  <button id="scalebt" class="button" onclick="s.setButton(this.id)">Scale</button>
  <button id="mirrorbt" class="button" onclick="s.setButton(this.id)">Mirror</button>
  <button id="removebt" class="button" onclick="s.setButton(this.id)">Remove</button>
</div>
<br><br><br><br>
<canvas id="myCanvas" width="1280" height="550">
</body>

<script>
var s = new CanvasState(document.getElementById("myCanvas"));
var shapeType = {
    POINT: 1,
    LINE: 2,
    POLYGON: 3,
};

// Um ponto contém a sua coordenada x, y
function Point(x, y) {
    this.x = x || 0;
    this.y = y || 0;
    this.w = this.h = 6;
    this.fill = '#000000';
    this.shapeType = shapeType.POINT;
}

// Uma linha contém uma coordenada inicial (start) e uma coordenada final (end)
function Line(start, end) {
    this.start = start || {x: 0, y: 0};
    this.end = end || {x: 0, y: 0};
    this.stroke = '#000000';
    this.shapeType = shapeType.LINE;
}

function Polygon() {
    this.lines = [];
    this.stroke = '#000000';
    this.shapeType = shapeType.POLYGON;
}

Polygon.prototype.getLinesLenght = function() {
    var l = this.lines.length;
    return l;
}

// Um objeto é um vetor com n formas
// Podem ser um ponto, uma linha ou um polígono
function Object(shape) {
    this.shape = shape;
    this.shapeType = shape.shapeType;
}

// Determina se a posição do mouse é válida sobre as formas
Object.prototype.contains = function(currMousePos) {
    if(this.shapeType == shapeType.POINT) {
        return this.pickPoint(currMousePos);
    } else if(this.shapeType == shapeType.LINE) {
        return this.pickLine(currMousePos);
    } else if(this.shapeType == shapeType.POLYGON){
        return this.pickPolygon(currMousePos);
    } else return false;
}

// Determina se a posição do mouse é válida sobre pontos
Object.prototype.pickPoint = function(currMousePos) {
    return (this.shape.x <= currMousePos.x) && (this.shape.x + this.shape.w >= currMousePos.x) &&
           (this.shape.y <= currMousePos.y) && (this.shape.y + this.shape.h >= currMousePos.y)
}

// Calcula código de 4 elementos para pick de linha
Object.prototype.pickCode = function(x, y, xmin, xmax, ymin, ymax, cod) {
    cod[0] = x < xmin;
    cod[1] = x > xmax;
    cod[2] = y < ymin;
    cod[3] = y > ymax;
}

// Determina se a posição do mouse é válida sobre linhas
Object.prototype.pickLine = function(currMousePos) {
    var cod0 = [], cod1 = [];
    var x0, y0, x1, y1;
    var xmin, xmax, ymin, ymax;
    var TOL = 5; // 5 pixels de tolerância

    // Define os limites baseado na tolerância
    xmin = currMousePos.x - TOL;
    xmax = currMousePos.x + TOL;
    ymin = currMousePos.y - TOL;
    ymax = currMousePos.y + TOL;

    // Testa a reta
    var line = this.shape;
    x0 = line.start.x;
    y0 = line.start.y;
    x1 = line.end.x;
    y1 = line.end.y;
    this.pickCode(x1, y1, xmin, xmax, ymin, ymax, cod1);
    do {
        this.pickCode(x0, y0, xmin, xmax, ymin, ymax, cod0);
        for(var j = 0; j < 4; j++) {
            if(cod0[j] && cod1[j]) break;
        }
        if(j != 4) break;
        if(cod0[0]) y0 += (xmin - x0) * (y1 - y0) / (x1 - x0), x0 = xmin;
        else if(cod0[1]) y0 += (xmax - x0) * (y1 - y0) / (x1 - x0), x0 = xmax;
        else if(cod0[2]) x0 += (ymin - y0) * (x1 - x0) / (y1 - y0), y0 = ymin;
        else if(cod0[3]) x0 += (ymax - y0) * (x1 - x0) / (y1 - y0), y0 = ymax;
           else return true;
    } while(true);
    return false;
}

// Determina se a posição do mouse é válida dentro de um polígono
Object.prototype.pickPolygon = function(currMousePos) {
    var ni = 0;
    return false;
}

// Desenha o objeto em um context
Object.prototype.draw = function(ctx) {
    // Desenha cada linha de um objeto
    var shape = this.shape;
    if(this.shapeType == shapeType.POINT) {
        ctx.fillStyle = shape.fill;
        ctx.fillRect(shape.x, shape.y, shape.w, shape.h);
    } else if(this.shapeType == shapeType.LINE) {
        ctx.beginPath();
        ctx.moveTo(shape.start.x, shape.start.y);
        ctx.lineTo(shape.end.x, shape.end.y);
        ctx.strokeStyle = shape.stroke;
        ctx.stroke();
    } else if(this.shapeType == shapeType.POLYGON){
        var l = shape.lines.length;
        for(var i = 0; i < l; i++) {
            var line = shape.lines[i];
            ctx.beginPath();
            ctx.moveTo(line.start.x, line.start.y);
            ctx.lineTo(line.end.x, line.end.y);
            ctx.strokeStyle = shape.stroke;
            ctx.stroke();
        }
    }
}

// CanvasState toma conta do estado do canvas
// Nele encontram-se os métodos para eventos do mouse, e também métodos de update no canvas, no caso de alguma movimentação ou transformação em algum objeto presente nele
// Os objetos (linhas, polígonos e poligonais) são salvos na lista shapes[]
function CanvasState(canvas) {
    // Atributos
    this.canvas = canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.ctx = canvas.getContext('2d');

    this.valid = false;
    this.objects = [];  // Objetos criados na tela
    this.dragging = false; // Flag para quando se está arrastando um objeto
    this.drawing = false; // Flag para quando se está desenhando um objeto
    this.selection = null; // Objeto selecionado
    this.startline = true; // Usado para desenhar linhas
    this.prevMousePos = {x: 0, y: 0}; // Salva o primeiro click do mouse ao desenhar
    this.mouseDownFired = false; // Usado para mover sem desenhar
    this.button = 0; // Botão selecionado
    this.newPolygon = null; // Polígono a ser adicionado

    // Dentro dos eventos do mouse, o "this" corresponde ao canvas, por isso precisa-se guardar o CanvasState em uma variável
    var myState = this;

    canvas.addEventListener('mousemove', function(e) {
        var currMousePos = myState.getMousePos(e);
        if(myState.drawing) {
            if(myState.button == 2) {
                myState.drawLine(currMousePos);
            } else if(myState.button == 3) {
                myState.drawPolygon(currMousePos);
            }
            myState.valid = false;
        }
        else if(myState.dragging) {
            myState.dragShape(currMousePos);
            myState.valid = false;
        }
        myState.writeMousePos("Mouse position on canvas: " + currMousePos.x + ',' + currMousePos.y);
    }, true);


    canvas.addEventListener('click', function(e) {
        // Se 'mousedown' estiver ativo, 'click' não será disparado
        if(myState.mouseDownFired) {
            myState.mouseDownFired = false;
            return;
        }
        var currMousePos = myState.getMousePos(e);
        if(myState.button == 1) {
            myState.addObject(new Point(currMousePos.x - 3, currMousePos.y - 3));
        } else if(myState.button == 2) {
            if(myState.startline) { // Primeiro click
                myState.startline = false; 
                myState.drawing = true;
                myState.prevMousePos = currMousePos;
            } else {                // Segundo click
                myState.startline = true; 
                myState.drawing = false;
                myState.addObject(new Line(myState.prevMousePos, currMousePos));
            }
        } else if(myState.button == 3) {
            if(myState.startline) {
                myState.newPolygon = new Polygon();
                myState.newPolygon.lines.push(new Line(currMousePos, currMousePos));
                myState.startline = false;
                myState.drawing = true;
                myState.prevMousePos = currMousePos;
                myState.addObject(myState.newPolygon);
            } else {
                var polygon = myState.objects[myState.getObjectsLenght() - 1].shape;
                polygon.lines.push(new Line(myState.prevMousePos, currMousePos));
                myState.prevMousePos = currMousePos;
            }
        }

        if(myState.selection) {
            myState.selection = null;
            myState.valid = false;
        }
    }, true);

    canvas.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        // Finaliza o polígono
        if(myState.newPolygon != null) {
            var polygon = myState.objects[myState.getObjectsLenght() - 1].shape;
            var l = polygon.lines.length;
            // Caso não seja fechado um polígono, remove-o da lista de objetos
            if(l <= 2) {
                myState.removeObject();
                myState.resetState();
                return false;
            }
            var lineStart = polygon.lines[0];
            var lineEnd = polygon.lines[l-1];
            polygon.lines.push(new Line(lineEnd.end, lineStart.start));
            myState.resetState();
        }
        return false;
    });

    canvas.addEventListener('mousedown', function(e) {
        // Previne disparar um 'click'
        myState.mouseDownFired = true;
        if(myState.button == 5) {
            var currMousePos = myState.getMousePos(e);
            var objects = myState.objects;
            var l = objects.length;
            for(var i = l - 1; i >= 0; i--) {
                if(objects[i].contains(currMousePos)) {
                    var mySel = objects[i].shape;
                    myState.prevMousePos = currMousePos;
                    myState.dragging = true;
                    myState.selection = mySel;
                    myState.valid = false;
                    return;
                }
            }
        }
        if(myState.selection) {
            myState.selection = null;
            myState.valid = false;
        }
        // Permite disparar um 'click'
        myState.mouseDownFired = false;
    });

    canvas.addEventListener('mouseup', function(e) {
        myState.dragging = false;
    });

    this.selectionColor = '#CC0000';
    this.selectionWidth = 2; 
    this.interval = 10;
    setInterval(function() { myState.draw(); }, myState.interval);
}

// Adiciona um objeto à lista de objetos do canvas
CanvasState.prototype.addObject = function(shape) {
    var o = new Object(shape);
    this.objects.push(o);
    this.valid = false;
}

CanvasState.prototype.removeObject = function() {
    this.objects.pop();
}

// Limpa a tela para redesenhar o canvas em cada interval
CanvasState.prototype.clear = function() {
    this.ctx.clearRect(0, 0, this.width, this.height);
}

// Método chamado pelo INTERVAL
// Limpa o canvas e redesenha todos os objetos presentes em objects[]
CanvasState.prototype.draw = function() {
    if(!this.valid) {
        var ctx = this.ctx;
        //var objects = this.objects;
        this.clear();
        if(this.drawing) ctx.stroke(); // Evita que desenhe a mesma linha duas vezes

        // Desenha todos os objetos
        //var l = this.objects.length;
        var l = this.getObjectsLenght();
        for(var i = 0; i < l; i++) {
            var object = this.objects[i];
            this.objects[i].draw(ctx);
        }

        this.valid = true;
    }
}

CanvasState.prototype.getMousePos = function(e) {
    var rect = this.canvas.getBoundingClientRect();
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

CanvasState.prototype.writeMousePos = function(message) {
    document.getElementById("currMousePos").innerHTML = message;
}

CanvasState.prototype.drawLine = function(currMousePos) {
    this.ctx.beginPath();
    this.ctx.moveTo(this.prevMousePos.x, this.prevMousePos.y);
    this.ctx.lineTo(currMousePos.x, currMousePos.y);
}

CanvasState.prototype.drawPolygon = function(currMousePos) {
    var currPolygon = this.objects[this.getObjectsLenght() - 1].shape;
    var start = currPolygon.lines[0].start;
    this.ctx.beginPath();
    this.ctx.moveTo(this.prevMousePos.x, this.prevMousePos.y);
    this.ctx.lineTo(currMousePos.x, currMousePos.y);
    this.ctx.lineTo(start.x, start.y);
}

CanvasState.prototype.dragShape = function(currMousePos) {
    var dragx = currMousePos.x - this.prevMousePos.x;
    var dragy = currMousePos.y - this.prevMousePos.y;
    if(this.selection.shapeType == shapeType.POINT) {
        this.selection.x = currMousePos.x + dragx;
        this.selection.y = currMousePos.y + dragy;
    } else if(this.selection.shapeType == shapeType.LINE) {
        var newStart = {x: 0, y: 0}, newEnd = {x: 0, y: 0};
        newStart.x = this.selection.start.x + dragx; newStart.y = this.selection.start.y + dragy;
        newEnd.x = this.selection.end.x + dragx; newEnd.y = this.selection.end.y + dragy;
        this.selection.start = newStart;
        this.selection.end = newEnd;
    } else if(this.selection.shapeType == shapeType.POLYGON) {
        // TODO
    }
    this.prevMousePos = currMousePos;
}

CanvasState.prototype.setButton = function(id) {
    switch(id) {
        case "pointbt"   : this.button = 1; break;
        case "linebt"    : this.button = 2; this.resetState(); break;
        case "polygonbt" : this.button = 3; this.resetState(); break;
        case "bezierbt"  : this.button = 4; break;
        case "movebt"    : this.button = 5; break;
        case "rotatebt"  : this.button = 6; break;
        case "scalebt"   : this.button = 7; break;
        case "mirrorbt"  : this.button = 8; break;
        case "removebt"  : this.button = 9; break;
        default          : this.button = 0;
    }
}

CanvasState.prototype.resetState = function() {
    this.newPolygon = null;
    this.startline = true;
    this.drawing = false;
    this.valid = false;
}

// Método de auxílio
CanvasState.prototype.isMovable = function(currMousePos) {
    var l = this.objects.length;
    for(var i = 0; i < l; i++) {
        var object = this.objects[i];
        var movable = object.contains(currMousePos);
        if(movable) break;
    }
    document.getElementById("status").innerHTML = "Status: " + movable;
}

CanvasState.prototype.getObjectsLenght = function() {
    var l = this.objects.length;
    return l;
}

</script>
</html>