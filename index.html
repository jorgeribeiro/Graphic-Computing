<!DOCTYPE html>
<html>
<head>
<title>HTML5 Canvas Paint</title>
<meta name="viewport" content="width=device-width, initial-scale=1" charset="utf-8"/>
<style>
body {
    font-family: Verdana,sans-serif;
    font-size: 13px;
}
canvas {
    border: 1px solid #d3d3d3;
    background-color: #f1f1f1;
}
.btn-group .button {
    background-color: #4CAF50;
    border: 1px solid green;
    color: white;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    cursor: pointer;
    float: left;
}
.btn-group .button:not(:last-child) {
    border-right: none;
}
.btn-group .button:hover {
    background-color: #3e8e41;
}
</style>
</head>
<body>
<p id="currMousePos">Mouse position on canvas: </p>
<p id="status" hidden="true">Button: </p> <!-- Para testes necessários -->
<div class="btn-group">
  <button id="pointbt" class="button" onclick="s.setButton(this.id)">Point</button>
  <button id="linebt" class="button" onclick="s.setButton(this.id)">Line</button>
  <button id="polygonbt" class="button" onclick="s.setButton(this.id)">Polygon</button>
  <button id="bezierbt" class="button" onclick="s.setButton(this.id)">Bezier</button>
  <button id="movebt" class="button" onclick="s.setButton(this.id)">Move</button>
  <button id="rotatebt" class="button" onclick="s.setButton(this.id)">Rotate</button>
  <button id="scalebt" class="button" onclick="s.setButton(this.id)">Scale</button>
  <button id="mirrorbt" class="button" onclick="s.setButton(this.id)">Mirror</button>
  <button id="removebt" class="button" onclick="s.setButton(this.id)">Remove</button>
</div>
<br><br><br><br>
<canvas id="myCanvas" width="1280" height="550">
</body>

<script>
var s = new CanvasState(document.getElementById("myCanvas"));
// Uma linha contém uma coordenada inicial (start) e uma coordenada final (end)
function Line(start, end) {
    this.start = start || {x: 0, y: 0};
    this.end = end || {x: 0, y: 0};
    this.stroke = '#000000';
}

// Um objeto é um vetor com n linhas
function Object(polygon) {
    this.lines = [];
    this.polygon = polygon || false;
}

// Determina se a posição do mouse é válida sobre formas
Object.prototype.contains = function(currMousePos) {
    return this.pickLine(currMousePos); // Pick de linha
}

// Calcula código de 4 elementos para pick de linha
Object.prototype.pickCode = function(x, y, xmin, xmax, ymin, ymax, cod) {
    cod[0] = x < xmin;
    cod[1] = x > xmax;
    cod[2] = y < ymin;
    cod[3] = y > ymax;
}

// Determina se a posição do mouse é válida sobre linhas
Object.prototype.pickLine = function(currMousePos) {
    var cod0 = [], cod1 = [];
    var x0, y0, x1, y1;
    var xmin, xmax, ymin, ymax;
    var TOL = 5; // 5 pixels de tolerância

    // Define os limites baseado na tolerância
    xmin = currMousePos.x - TOL;
    xmax = currMousePos.x + TOL;
    ymin = currMousePos.y - TOL;
    ymax = currMousePos.y + TOL;

    // Testa cada reta simples
    var l = this.lines.length;
    for(var i = 0; i < l; i++) {
        var line = this.lines[i];
        x0 = line.start.x;
        y0 = line.start.y;
        x1 = line.end.x;
        y1 = line.end.y;

        this.pickCode(x1, y1, xmin, xmax, ymin, ymax, cod1);
        do {
            this.pickCode(x0, y0, xmin, xmax, ymin, ymax, cod0);
            for(var j = 0; j < 4; j++) {
                if(cod0[j] && cod1[j]) break;
            }
            if(j != 4) break;
            if(cod0[0]) y0 += (xmin - x0) * (y1 - y0) / (x1 - x0), x0 = xmin;
            else if(cod0[1]) y0 += (xmax - x0) * (y1 - y0) / (x1 - x0), x0 = xmax;
            else if(cod0[2]) x0 += (ymin - y0) * (x1 - x0) / (y1 - y0), y0 = ymin;
            else if(cod0[3]) x0 += (ymax - y0) * (x1 - x0) / (y1 - y0), y0 = ymax;
            else return true;
        } while(true);
    }
    return false;
}

// Desenha o objeto em um context
Object.prototype.draw = function(ctx) {
    // Desenha cada linha de um objeto
    var l = this.lines.length;
    for(var i = 0; i < l; i++) {
        var line = this.lines[i];
        ctx.beginPath();
        ctx.moveTo(line.start.x, line.start.y);
        ctx.lineTo(line.end.x, line.end.y);
        ctx.strokeStyle = line.stroke;
        ctx.stroke();
    }
}

// CanvasState toma conta do estado do canvas
// Nele encontram-se os métodos para eventos do mouse, e também métodos de update no canvas, no caso de alguma movimentação ou transformação em algum objeto presente nele
// Os objetos (linhas, polígonos e poligonais) são salvos na lista shapes[]
function CanvasState(canvas) {
    // Atributos
    this.canvas = canvas;
    this.width = canvas.width;
    this.height = canvas.height;
    this.ctx = canvas.getContext('2d');

    this.valid = false;
    this.objects = [];  // Objetos criados na tela
    this.dragging = false; // Flag para quando se está arrastando um objeto
    this.drawing = false; // Flag para quando se está desenhando um objeto
    this.selection = null; // Objeto selecionado
    this.startline = true; // Usado para desenhar linhas
    this.prevMousePos = {x: 0, y: 0}; // Salva o primeiro click do mouse ao desenhar
    this.mouseDownFired = false; // Usado para mover sem desenhar
    this.button = 0; // Botão selecionado

    // Dentro dos eventos do mouse, o "this" corresponde ao canvas, por isso precisa-se guardar o CanvasState em uma variável
    var myState = this;

    canvas.addEventListener('mousemove', function(e) {
        var currMousePos = myState.getMousePos(e);
        if(myState.drawing) {
            myState.drawLine(currMousePos);
            myState.valid = false;
        }
        else if(myState.dragging) {
            myState.dragLine(currMousePos);
            myState.valid = false;
        }
        myState.writeMousePos("Mouse position on canvas: " + currMousePos.x + ',' + currMousePos.y);
        myState.isMovable(currMousePos);
    }, true);


    canvas.addEventListener('click', function(e) {
        // Se 'mousedown' estiver ativo, 'click' não será disparado
        if(myState.mouseDownFired) {
            myState.mouseDownFired = false;
            return;
        }
        if(myState.button == 2) {
            var currMousePos = myState.getMousePos(e);
            if(myState.startline) { // Primeiro click
                myState.startline = false; 
                myState.drawing = true;
                myState.prevMousePos = currMousePos;
            } else {                // Segundo click
                myState.startline = true; 
                myState.drawing = false;
                myState.addObject(new Line(myState.prevMousePos, currMousePos));
            }
        }

        if(myState.selection) {
            myState.selection = null;
            myState.valid = false;
        }
    }, true);

    canvas.addEventListener('mousedown', function(e) {
        // Previne disparar um 'click'
        myState.mouseDownFired = true;
        if(myState.button == 5) {
            var currMousePos = myState.getMousePos(e);
            var objects = myState.objects;
            var l = objects.length;
            for(var i = l - 1; i >= 0; i--) {
                if(objects[i].contains(currMousePos)) {
                    var mySel = objects[i].lines[0]; // TODO: por enquanto só move linhas
                    myState.prevMousePos = currMousePos;
                    myState.dragging = true;
                    myState.selection = mySel;
                    myState.valid = false;
                    return;
                }
            }
        }
        if(myState.selection) {
            myState.selection = null;
            myState.valid = false;
        }

        // Permite disparar um 'click'
        myState.mouseDownFired = false;
    });

    canvas.addEventListener('mouseup', function(e) {
        myState.dragging = false;
    });

    this.selectionColor = '#CC0000';
    this.selectionWidth = 2; 
    this.interval = 10;
    setInterval(function() { myState.draw(); }, myState.interval);
}

// Prototype corresponde a adicionar um novo atributo ao "objeto" existente
CanvasState.prototype.addObject = function(line) {
    var o = new Object();
    o.lines.push(line);
    this.objects.push(o);
    this.valid = false;
}

// Limpa a tela para redesenhar o canvas em cada interval
CanvasState.prototype.clear = function() {
    this.ctx.clearRect(0, 0, this.width, this.height);
}

// Método chamado pelo INTERVAL
// Limpa o canvas e redesenha todos os objetos presentes em objects[]
CanvasState.prototype.draw = function() {
    if(!this.valid) {
        var ctx = this.ctx;
        var objects = this.objects;
        this.clear();
        if(this.drawing) ctx.stroke(); // Evita que desenhe a mesma linha duas vezes

        // Desenha todos os objetos
        var l = objects.length;
        for(var i = 0; i < l; i++) {
            var object = objects[i];
            objects[i].draw(ctx);
        }

        this.valid = true;
    }
}

CanvasState.prototype.getMousePos = function(e) {
    var rect = this.canvas.getBoundingClientRect();
    return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
    };
}

CanvasState.prototype.writeMousePos = function(message) {
    document.getElementById("currMousePos").innerHTML = message;
}

CanvasState.prototype.drawLine = function(currMousePos) {
    this.ctx.beginPath();
    this.ctx.moveTo(this.prevMousePos.x, this.prevMousePos.y);
    this.ctx.lineTo(currMousePos.x, currMousePos.y);
}

CanvasState.prototype.dragLine = function(currMousePos) {
    var dragx = currMousePos.x - this.prevMousePos.x;
    var dragy = currMousePos.y - this.prevMousePos.y;
    var newStart = {x: 0, y: 0}, newEnd = {x: 0, y: 0};
    newStart.x = this.selection.start.x + dragx; newStart.y = this.selection.start.y + dragy;
    newEnd.x = this.selection.end.x + dragx; newEnd.y = this.selection.end.y + dragy;
    this.selection.start = newStart;
    this.selection.end = newEnd;
    this.prevMousePos = currMousePos;
}

CanvasState.prototype.isMovable = function(currMousePos) {
    var l = this.objects.length;
    for(var i = 0; i < l; i++) {
        var object = this.objects[i];
        var movable = object.contains(currMousePos);
        if(movable) break; // Se estou sobre uma reta válida, não precisa testar as outras
    }
}

CanvasState.prototype.setButton = function(id) {
    switch(id) {
        case "pointbt"   : this.button = 1; break;
        case "linebt"    : this.button = 2; break;
        case "polygonbt" : this.button = 3; break;
        case "bezierbt"  : this.button = 4; break;
        case "movebt"    : this.button = 5; break;
        case "rotatebt"  : this.button = 6; break;
        case "scalebt"   : this.button = 7; break;
        case "mirrorbt"  : this.button = 8; break;
        case "removebt"  : this.button = 9; break;
        default          : this.button = 0;
    }
}

</script>
</html>